<!DOCTYPE html>
<html>
	<head>
		<title> Raymarching Distance Fields&#58; Concepts and Implementation in Unity </title>
		<link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,700italic,400,700|Roboto' rel='stylesheet' type='text/css'>

		<link rel="stylesheet" type="text/css" href="/css/all.css" />
		<link rel="stylesheet" type="text/css" href="/css/syntax.css" />
		<script defer src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
		<script defer type="text/javascript" src="/js/all.js"></script>
		<script defer type"text/javascript" src="https://assets.gfycat.com/gfycat.js"></script>

		<meta name="viewport" content="width=device-width">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		
		<script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

		  ga('create', 'UA-53642959-1', 'auto');
		  ga('send', 'pageview');

		</script>
	</head>
	<body>
		<div class="header">
			<h1 class="grad_text">adrian's soapbox</h1>
			<div class="nav" id="mobile">
				<div class="grad_text">open navigation</div>
			</div>
			<div class="nav" id="desktop">
				<a class="nava" href="/index.html"><div class="navlink">home</div></a>
				<a class="nava" href="/about"><div class="navlink">about</div></a>
				<a class="nava" href="https://github.com/Flafla2"><div class="navlink">github</div></a>
			</div>
			<div id="navlinks">
				<a class="nava" href="/index.html"><div class="navlink">home</div></a>
				<a class="nava" href="/about"><div class="navlink">about</div></a>
				<a class="nava" href="https://github.com/Flafla2"><div class="navlink">github</div></a>
			</div>
		</div>
		<div class="content">

<div class="article" style="border-bottom: none;">
	<h1>Raymarching Distance Fields&#58; Concepts and Implementation in Unity</h1>
	<p class="postinfo">
	
	
	
	
	
	<a href="/tags/tech_writeup/"><span class="post_tag">Technical Writeup</span></a>
	
	
	
	Posted on 01 October 2016 by Flafla2
	</p>
	<p><em>Raymarching</em> is a fairly new technique used to render realtime scenes.  The technique is particularly interesting because it is entirely computed in a screen-space shader.  In other words, no mesh data is provided to the renderer and the scene is drawn on a single quad that covers the camera’s field of vision.  Objects in the scene are defined by an analytic equation that describes the shortest distance between a point and the surface of any object in the scene (hence the full name <em>Raymarching Distance Fields</em>).  It turns out that with only this information you can compose some strikingly complicated and beautiful scenes.  Further, because you aren’t using polygonal meshes (and are instead using mathematical equations) it is possible to define perfectly smooth surfaces, unlike in a traditional renderer.</p>

<p style="text-align: center">
    <img src="/img/2016-10-01-raymarching/snail.png" style="text-align: center; width: 100%; max-width: 350px;" /><br />
    <i><a href="https://www.shadertoy.com/view/ld3Gz2">Snail</a> by Inigo Quilez was created entirely using raymarching.  You can find more examples of raymarched scenes on <a href="https://www.shadertoy.com">Shadertoy</a>.</i>
</p>

<p>This article will first discuss the fundamental concepts and theory of raymarching.  Then it will show how to implement a basic raymarcher in the Unity game engine.  Finally it will show how to integrate raymarching practically in a real Unity game by allowing raymarched objects to be occluded by normal Unity GameObjects.</p>

<p>You can find a complete reference implementation at <a href="https://github.com/Flafla2/Generic-Raymarch-Unity">this Github Repository</a>.
<!--break--></p>

<h2 class="no_toc" id="table-of-contents">Table of Contents</h2>

<ul id="markdown-toc">
  <li><a href="#introduction-to-raymarching" id="markdown-toc-introduction-to-raymarching">Introduction to Raymarching</a>    <ul>
      <li><a href="#enter-distance-fields" id="markdown-toc-enter-distance-fields">Enter distance fields</a></li>
    </ul>
  </li>
  <li><a href="#implementing-a-basic-raymarcher" id="markdown-toc-implementing-a-basic-raymarcher">Implementing a Basic Raymarcher</a>    <ul>
      <li><a href="#setting-up-the-image-effect-script" id="markdown-toc-setting-up-the-image-effect-script">Setting up the Image Effect Script</a></li>
      <li><a href="#passing-rays-to-the-fragment-shader" id="markdown-toc-passing-rays-to-the-fragment-shader">Passing Rays to the Fragment Shader</a>        <ul>
          <li><a href="#step-1-computing-the-view-frustum-corners" id="markdown-toc-step-1-computing-the-view-frustum-corners">Step 1: Computing the View Frustum corners</a></li>
          <li><a href="#step-2-passing-the-rays-to-the-gpu" id="markdown-toc-step-2-passing-the-rays-to-the-gpu">Step 2: Passing the Rays to the GPU</a></li>
          <li><a href="#step-3-receiving-the-ray-directions-in-your-shader" id="markdown-toc-step-3-receiving-the-ray-directions-in-your-shader">Step 3: Receiving the Ray Directions in your Shader</a></li>
        </ul>
      </li>
      <li><a href="#building-the-distance-field" id="markdown-toc-building-the-distance-field">Building the Distance Field</a></li>
      <li><a href="#writing-the-raymarch-function" id="markdown-toc-writing-the-raymarch-function">Writing the Raymarch Function</a></li>
    </ul>
  </li>
  <li><a href="#adding-lighting" id="markdown-toc-adding-lighting">Adding Lighting</a></li>
  <li><a href="#interacting-with-mesh-based-objects" id="markdown-toc-interacting-with-mesh-based-objects">Interacting With Mesh-Based Objects</a>    <ul>
      <li><a href="#using-the-depth-buffer-in-our-shader" id="markdown-toc-using-the-depth-buffer-in-our-shader">Using the depth buffer in our shader</a></li>
    </ul>
  </li>
  <li><a href="#fun-with-distance-fields" id="markdown-toc-fun-with-distance-fields">Fun with Distance Fields</a>    <ul>
      <li><a href="#basic-transformations" id="markdown-toc-basic-transformations">Basic Transformations</a></li>
      <li><a href="#combining-objects" id="markdown-toc-combining-objects">Combining Objects</a></li>
      <li><a href="#multiple-materials" id="markdown-toc-multiple-materials">Multiple Materials</a></li>
      <li><a href="#performance-testing" id="markdown-toc-performance-testing">Performance Testing</a></li>
    </ul>
  </li>
  <li><a href="#closing-remarks" id="markdown-toc-closing-remarks">Closing Remarks</a></li>
  <li><a href="#references" id="markdown-toc-references">References</a></li>
</ul>

<h2 id="introduction-to-raymarching">Introduction to Raymarching</h2>

<p>Raymarching is similar to traditional raytracing in that a ray is cast into the scene for each pixel.  In a raytracer, you are given a set of equations that determine the intersection of a ray and the objects you are rendering.  This way it is possible to find which objects the ray intersects (that is, the objects that the camera sees).  It is also possible to render nonpolygonal objects such as spheres because you only need to know the sphere / ray intersection formula (for example).  However, raytracing is very expensive, especially when you have many objects and complex lighting.  Additionally you can not raytrace through volumetric materials, such as clouds and water.  Therefore raytracing is largely inadequate for realtime applications.</p>

<p style="text-align: center">
    <img src="/img/2016-10-01-raymarching/figure1.png" style="text-align: center; width: 100%; max-width: 450px;" /><br />
    <i>Figure 1: Simplified representation of a raytracer.  The thick black line is an example ray cast to render a pixel from the camera.</i>
</p>

<p>Raymarching takes an alternative approach to the ray / object intersection problem.  Raymarching does not try to directly calculate this intersection analytically.  Instead, <strong>in raymarching we “march” a point along the ray until we find that the point intersects an object</strong>.  It turns out that sampling this point along the ray is a relatively simple and inexpensive operation, and much more practical in realtime.  As you can see in figure 2, this method is less accurate than raytracing (if you look closely the intersection point is slightly off).  For games however it is more than adequate, and is a great compromise between the efficiency of polygonal rendering and the accuracy of traditional raytracing.</p>

<p style="text-align: center">
    <img src="/img/2016-10-01-raymarching/figure2.png" style="text-align: center; width: 100%; max-width: 450px;" /><br />
    <i>Figure 2: Basic implementation of a raymarcher with a fixed marching interval.  The red dots represent each sample point.</i>
</p>

<h3 id="enter-distance-fields">Enter distance fields</h3>

<p>A <em>fixed interval</em> raymarcher such as the one shown in Figure 2 is sufficient for many applications such as volumetric or transparent surfaces.  However, for opaque objects we can introduce another optimization.  This optimization calls for the use of <em>signed distance fields</em>.  <strong>A <em>distance field</em> is a function that takes in a point as input and returns the shortest distance from that point to the surface any object in the scene.</strong>  A <em>signed</em> distance field additionally returns a negative number if the input point is inside of an object.  Distance fields are great because they allow us to limit how often we need to sample when marching along the ray.  See the example below:</p>

<p style="text-align: center">
    <img src="/img/2016-10-01-raymarching/figure3.png" style="text-align: center; width: 100%; max-width: 450px;" /><br />
    <i>Figure 3: Visualization of a raymarcher using signed distance fields.  The red dots represent each sample point.  Each blue circle represents the area that is guaranteed to not contain any objects (because they are within the results of the distance field).  The dashed green lines represent the true shortest vector between each sample point and the scene.</i>
</p>

<p>As you can see above, the distance field allows us to march the ray by a maximal distance each step.</p>

<h2 id="implementing-a-basic-raymarcher">Implementing a Basic Raymarcher</h2>

<p>Because the raymarching algorithm is run on every pixel, a raymarcher in Unity is essentially a post processing shader.  Because of this, much of the C# code that we will write is similar to what you would use for a full-screen image effect.</p>

<h3 id="setting-up-the-image-effect-script">Setting up the Image Effect Script</h3>

<p>Let’s implement a basic image effect loading script.  A quick note: I am using the <a href="http://framebunker.com/blog/viewing-image-effects-in-the-scene-view/">SceneViewFilter</a> script to automatically apply image filters to the scene view.  This allows you to debug your shader more easily.  To use it, simply extend <code class="highlighter-rouge">SceneViewFilter</code> instead of <code class="highlighter-rouge">MonoBehaviour</code> in your image effect script.</p>

<p>Just to get the boilerplate code out of the way, a basic image effect script is shown below:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49</pre></td><td class="code"><pre><span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Collections</span><span class="p">;</span>

<span class="na">[ExecuteInEditMode]</span>
<span class="na">[RequireComponent(typeof(Camera))]</span>
<span class="na">[AddComponentMenu("Effects/Raymarch (Generic)")]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">TutorialRaymarch</span> <span class="p">:</span> <span class="n">SceneViewFilter</span> <span class="p">{</span>

    <span class="p">[</span><span class="n">SerializeField</span><span class="p">]</span>
    <span class="k">private</span> <span class="n">Shader</span> <span class="n">_EffectShader</span><span class="p">;</span>

    <span class="k">public</span> <span class="n">Material</span> <span class="n">EffectMaterial</span>
    <span class="p">{</span>
        <span class="k">get</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(!</span><span class="n">_EffectMaterial</span> <span class="p">&amp;&amp;</span> <span class="n">_EffectShader</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">_EffectMaterial</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Material</span><span class="p">(</span><span class="n">_EffectShader</span><span class="p">);</span>
                <span class="n">_EffectMaterial</span><span class="p">.</span><span class="n">hideFlags</span> <span class="p">=</span> <span class="n">HideFlags</span><span class="p">.</span><span class="n">HideAndDontSave</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="n">_EffectMaterial</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">private</span> <span class="n">Material</span> <span class="n">_EffectMaterial</span><span class="p">;</span>

    <span class="k">public</span> <span class="n">Camera</span> <span class="n">CurrentCamera</span>
    <span class="p">{</span>
        <span class="k">get</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(!</span><span class="n">_CurrentCamera</span><span class="p">)</span>
                <span class="n">_CurrentCamera</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">Camera</span><span class="p">&gt;();</span>
            <span class="k">return</span> <span class="n">_CurrentCamera</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">private</span> <span class="n">Camera</span> <span class="n">_CurrentCamera</span><span class="p">;</span>

    <span class="p">[</span><span class="n">ImageEffectOpaque</span><span class="p">]</span>
    <span class="k">void</span> <span class="nf">OnRenderImage</span><span class="p">(</span><span class="n">RenderTexture</span> <span class="n">source</span><span class="p">,</span> <span class="n">RenderTexture</span> <span class="n">destination</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(!</span><span class="n">EffectMaterial</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Graphics</span><span class="p">.</span><span class="nf">Blit</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">);</span> <span class="c1">// do nothing
</span>            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">Graphics</span><span class="p">.</span><span class="nf">Blit</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">EffectMaterial</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span> <span class="c1">// use given effect shader as image effect
</span>    <span class="p">}</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>To use this script, attach it to a camera and drag an image effect shader onto the “Effect Shader” field.  As a test, you can try the default image effect shader (Assets &gt; Create &gt; Shader &gt; Image Effects Shader), which simply inverts the screen.  With that out of the way, we can begin to get into the more technical aspects of the implementation.</p>

<h3 id="passing-rays-to-the-fragment-shader">Passing Rays to the Fragment Shader</h3>

<p>The first step in actually implementing a raymarcher is to calculate the ray that we will be using for each pixel.  We also want these rays to match up with the Unity render settings (such as the camera’s postion, rotation, FOV, etc).</p>

<p style="text-align: center">
    <img src="/img/2016-10-01-raymarching/figure4.png" style="width: 100%; max-width: 300px;" /><br />
    <i>Figure 4: A visualization of the rays sent out from the camera</i>
</p>

<p>There are many ways of doing this, but I have chosen to use the following procedure every frame:</p>

<ol>
  <li>Compute an array of four vectors that make up <a href="https://docs.unity3d.com/Manual/UnderstandingFrustum.html">Camera View Frustum</a>.  These four vectors can be thought of as the “corners” of the view frustum:
    <p style="text-align: center">
   <img src="/img/2016-10-01-raymarching/viewfrustum.png" style="width: 100%; max-width: 300px;" /><br />
   <i>The four view frustum corners that are later passed to the shader</i>
 </p>
  </li>
  <li>When rendering our raymarcher as an image effect shader, use our own custom replacement for <a href="https://docs.unity3d.com/ScriptReference/Graphics.Blit.html">Graphics.Blit()</a>.  Graphics.Blit essentially renders a quad over the entire screen, and this quad renders with the image effect shader.  We will add to this by, for each vertex, <em>passing the corresponding indices in the array we created in step 1</em>.  Now, the vertex shader is aware of the rays to cast at each corner of the screen!</li>
  <li>In the shader, pass the ray directions from step 2 into the fragment shader.  Cg will automatically interpolate the ray directions for each pixel, giving the true ray direction.</li>
</ol>

<p>Okay, now let’s implement the above process.</p>

<h4 id="step-1-computing-the-view-frustum-corners">Step 1: Computing the View Frustum corners</h4>

<p>To calculate the camera frustum corner rays, you have to take into account the field of view of the camera as well as the camera’s aspect ratio.  I have done this in the function <code class="highlighter-rouge">GetFrustumCorners</code> below:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33</pre></td><td class="code"><pre><span class="c1">/// \brief Stores the normalized rays representing the camera frustum in a 4x4 matrix.  Each row is a vector.
/// 
/// The following rays are stored in each row (in eyespace, not worldspace):
/// Top Left corner:     row=0
/// Top Right corner:    row=1
/// Bottom Right corner: row=2
/// Bottom Left corner:  row=3
</span><span class="k">private</span> <span class="n">Matrix4x4</span> <span class="nf">GetFrustumCorners</span><span class="p">(</span><span class="n">Camera</span> <span class="n">cam</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">camFov</span> <span class="p">=</span> <span class="n">cam</span><span class="p">.</span><span class="n">fieldOfView</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">camAspect</span> <span class="p">=</span> <span class="n">cam</span><span class="p">.</span><span class="n">aspect</span><span class="p">;</span>

    <span class="n">Matrix4x4</span> <span class="n">frustumCorners</span> <span class="p">=</span> <span class="n">Matrix4x4</span><span class="p">.</span><span class="n">identity</span><span class="p">;</span>

    <span class="kt">float</span> <span class="n">fovWHalf</span> <span class="p">=</span> <span class="n">camFov</span> <span class="p">*</span> <span class="m">0.5f</span><span class="p">;</span>

    <span class="kt">float</span> <span class="n">tan_fov</span> <span class="p">=</span> <span class="n">Mathf</span><span class="p">.</span><span class="nf">Tan</span><span class="p">(</span><span class="n">fovWHalf</span> <span class="p">*</span> <span class="n">Mathf</span><span class="p">.</span><span class="n">Deg2Rad</span><span class="p">);</span>

    <span class="n">Vector3</span> <span class="n">toRight</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">right</span> <span class="p">*</span> <span class="n">tan_fov</span> <span class="p">*</span> <span class="n">camAspect</span><span class="p">;</span>
    <span class="n">Vector3</span> <span class="n">toTop</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">up</span> <span class="p">*</span> <span class="n">tan_fov</span><span class="p">;</span>

    <span class="n">Vector3</span> <span class="n">topLeft</span> <span class="p">=</span> <span class="p">(-</span><span class="n">Vector3</span><span class="p">.</span><span class="n">forward</span> <span class="p">-</span> <span class="n">toRight</span> <span class="p">+</span> <span class="n">toTop</span><span class="p">);</span>
    <span class="n">Vector3</span> <span class="n">topRight</span> <span class="p">=</span> <span class="p">(-</span><span class="n">Vector3</span><span class="p">.</span><span class="n">forward</span> <span class="p">+</span> <span class="n">toRight</span> <span class="p">+</span> <span class="n">toTop</span><span class="p">);</span>
    <span class="n">Vector3</span> <span class="n">bottomRight</span> <span class="p">=</span> <span class="p">(-</span><span class="n">Vector3</span><span class="p">.</span><span class="n">forward</span> <span class="p">+</span> <span class="n">toRight</span> <span class="p">-</span> <span class="n">toTop</span><span class="p">);</span>
    <span class="n">Vector3</span> <span class="n">bottomLeft</span> <span class="p">=</span> <span class="p">(-</span><span class="n">Vector3</span><span class="p">.</span><span class="n">forward</span> <span class="p">-</span> <span class="n">toRight</span> <span class="p">-</span> <span class="n">toTop</span><span class="p">);</span>

    <span class="n">frustumCorners</span><span class="p">.</span><span class="nf">SetRow</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="n">topLeft</span><span class="p">);</span>
    <span class="n">frustumCorners</span><span class="p">.</span><span class="nf">SetRow</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="n">topRight</span><span class="p">);</span>
    <span class="n">frustumCorners</span><span class="p">.</span><span class="nf">SetRow</span><span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="n">bottomRight</span><span class="p">);</span>
    <span class="n">frustumCorners</span><span class="p">.</span><span class="nf">SetRow</span><span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="n">bottomLeft</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">frustumCorners</span><span class="p">;</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>It’s worth noting a couple of things about this function.  First, it returns a <code class="highlighter-rouge">Matrix4x4</code> instead of an array of Vector3’s.  This way, we can pass the vectors to our shader with a single variable (without having to use arrays).  Second, it returns the frustum corner rays in <em>eye space</em>.  This means that (0,0,0) is assumed to be the camera’s position, and the rays themselves are from the Camera’s point of view (instead of, for example, worldspace).</p>

<h4 id="step-2-passing-the-rays-to-the-gpu">Step 2: Passing the Rays to the GPU</h4>

<p>To pass this matrix to the shader, we need to make a slight modification to our Image Effect Script:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16</pre></td><td class="code"><pre><span class="na">[ImageEffectOpaque]</span>
<span class="k">void</span> <span class="nf">OnRenderImage</span><span class="p">(</span><span class="n">RenderTexture</span> <span class="n">source</span><span class="p">,</span> <span class="n">RenderTexture</span> <span class="n">destination</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(!</span><span class="n">EffectMaterial</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Graphics</span><span class="p">.</span><span class="nf">Blit</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">);</span> <span class="c1">// do nothing
</span>        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// pass frustum rays to shader
</span>    <span class="n">EffectMaterial</span><span class="p">.</span><span class="nf">SetMatrix</span><span class="p">(</span><span class="s">"_FrustumCornersES"</span><span class="p">,</span> <span class="nf">GetFrustumCorners</span><span class="p">(</span><span class="n">CurrentCamera</span><span class="p">));</span>
    <span class="n">EffectMaterial</span><span class="p">.</span><span class="nf">SetMatrix</span><span class="p">(</span><span class="s">"_CameraInvViewMatrix"</span><span class="p">,</span> <span class="n">CurrentCamera</span><span class="p">.</span><span class="n">cameraToWorldMatrix</span><span class="p">);</span>
    <span class="n">EffectMaterial</span><span class="p">.</span><span class="nf">SetVector</span><span class="p">(</span><span class="s">"_CameraWS"</span><span class="p">,</span> <span class="n">CurrentCamera</span><span class="p">.</span><span class="n">transform</span><span class="p">.</span><span class="n">position</span><span class="p">);</span>

    <span class="n">Graphics</span><span class="p">.</span><span class="nf">Blit</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">EffectMaterial</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span> <span class="c1">// use given effect shader as image effect
</span><span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Later, when we work on the image effect shader itself, we can access this matrix using the uniform <code class="highlighter-rouge">_FrustumCornersES</code>.  I also threw in some camera-related information that we will need later (<code class="highlighter-rouge">_CameraInvViewMatrix</code> will be used to convert the rays from eye space to world space, and <code class="highlighter-rouge">_CameraWS</code> is the camera’s position).</p>

<p>Next up, we need to give the vertex shader the tools to interpret this matrix correctly.  Remember: an image effect is simply a quad drawn over the entire screen, so we need to somehow pass the corresponding index of <code class="highlighter-rouge">_FrustumCornersES</code> to each vertex in the vertex shader.  To do this, we need to use our own custom replacement to <code class="highlighter-rouge">Graphics.Blit</code> (line 13 above).  In this custom version, we will use a sneaky trick: because the quad in <code class="highlighter-rouge">Graphics.Blit</code> is drawn using <a href="http://blender.stackexchange.com/questions/648/what-are-the-differences-between-orthographic-and-perspective-views">Orthographic Projection</a>, the <code class="highlighter-rouge">z</code> position of each vertex doesn’t affect the final image.  So, we can simply pass the corresponding indices of <code class="highlighter-rouge">_FrustumCornersES</code> through the <code class="highlighter-rouge">z</code> coordinate of each vertex!  This sounds complicated, but is quite simple in practice:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51</pre></td><td class="code"><pre><span class="c1">/// \brief Custom version of Graphics.Blit that encodes frustum corner indices into the input vertices.
/// 
/// In a shader you can expect the following frustum cornder index information to get passed to the z coordinate:
/// Top Left vertex:     z=0, u=0, v=0
/// Top Right vertex:    z=1, u=1, v=0
/// Bottom Right vertex: z=2, u=1, v=1
/// Bottom Left vertex:  z=3, u=1, v=0
/// 
/// \warning You may need to account for flipped UVs on DirectX machines due to differing UV semantics
///          between OpenGL and DirectX.  Use the shader define UNITY_UV_STARTS_AT_TOP to account for this.
</span><span class="k">static</span> <span class="k">void</span> <span class="nf">CustomGraphicsBlit</span><span class="p">(</span><span class="n">RenderTexture</span> <span class="n">source</span><span class="p">,</span> <span class="n">RenderTexture</span> <span class="n">dest</span><span class="p">,</span> <span class="n">Material</span> <span class="n">fxMaterial</span><span class="p">,</span> <span class="kt">int</span> <span class="n">passNr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">RenderTexture</span><span class="p">.</span><span class="n">active</span> <span class="p">=</span> <span class="n">dest</span><span class="p">;</span>

    <span class="n">fxMaterial</span><span class="p">.</span><span class="nf">SetTexture</span><span class="p">(</span><span class="s">"_MainTex"</span><span class="p">,</span> <span class="n">source</span><span class="p">);</span>

    <span class="n">GL</span><span class="p">.</span><span class="nf">PushMatrix</span><span class="p">();</span>
    <span class="n">GL</span><span class="p">.</span><span class="nf">LoadOrtho</span><span class="p">();</span> <span class="c1">// Note: z value of vertices don't make a difference because we are using ortho projection
</span>
    <span class="n">fxMaterial</span><span class="p">.</span><span class="nf">SetPass</span><span class="p">(</span><span class="n">passNr</span><span class="p">);</span>

    <span class="n">GL</span><span class="p">.</span><span class="nf">Begin</span><span class="p">(</span><span class="n">GL</span><span class="p">.</span><span class="n">QUADS</span><span class="p">);</span>

    <span class="c1">// Here, GL.MultitexCoord2(0, x, y) assigns the value (x, y) to the TEXCOORD0 slot in the shader.
</span>    <span class="c1">// GL.Vertex3(x,y,z) queues up a vertex at position (x, y, z) to be drawn.  Note that we are storing
</span>    <span class="c1">// our own custom frustum information in the z coordinate.
</span>    <span class="n">GL</span><span class="p">.</span><span class="nf">MultiTexCoord2</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0.0f</span><span class="p">,</span> <span class="m">0.0f</span><span class="p">);</span>
    <span class="n">GL</span><span class="p">.</span><span class="nf">Vertex3</span><span class="p">(</span><span class="m">0.0f</span><span class="p">,</span> <span class="m">0.0f</span><span class="p">,</span> <span class="m">3.0f</span><span class="p">);</span> <span class="c1">// BL
</span>
    <span class="n">GL</span><span class="p">.</span><span class="nf">MultiTexCoord2</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">1.0f</span><span class="p">,</span> <span class="m">0.0f</span><span class="p">);</span>
    <span class="n">GL</span><span class="p">.</span><span class="nf">Vertex3</span><span class="p">(</span><span class="m">1.0f</span><span class="p">,</span> <span class="m">0.0f</span><span class="p">,</span> <span class="m">2.0f</span><span class="p">);</span> <span class="c1">// BR
</span>
    <span class="n">GL</span><span class="p">.</span><span class="nf">MultiTexCoord2</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">1.0f</span><span class="p">,</span> <span class="m">1.0f</span><span class="p">);</span>
    <span class="n">GL</span><span class="p">.</span><span class="nf">Vertex3</span><span class="p">(</span><span class="m">1.0f</span><span class="p">,</span> <span class="m">1.0f</span><span class="p">,</span> <span class="m">1.0f</span><span class="p">);</span> <span class="c1">// TR
</span>
    <span class="n">GL</span><span class="p">.</span><span class="nf">MultiTexCoord2</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0.0f</span><span class="p">,</span> <span class="m">1.0f</span><span class="p">);</span>
    <span class="n">GL</span><span class="p">.</span><span class="nf">Vertex3</span><span class="p">(</span><span class="m">0.0f</span><span class="p">,</span> <span class="m">1.0f</span><span class="p">,</span> <span class="m">0.0f</span><span class="p">);</span> <span class="c1">// TL
</span>    
    <span class="n">GL</span><span class="p">.</span><span class="nf">End</span><span class="p">();</span>
    <span class="n">GL</span><span class="p">.</span><span class="nf">PopMatrix</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// ...
</span>
<span class="k">void</span> <span class="nf">OnRenderImage</span><span class="p">(</span><span class="n">RenderTexture</span> <span class="n">source</span><span class="p">,</span> <span class="n">RenderTexture</span> <span class="n">destination</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ...
</span>    <span class="n">EffectMaterial</span><span class="p">.</span><span class="nf">SetMatrix</span><span class="p">(</span><span class="s">"_FrustumCornersES"</span><span class="p">,</span> <span class="nf">GetFrustumCorners</span><span class="p">(</span><span class="n">CurrentCamera</span><span class="p">));</span>

    <span class="nf">CustomGraphicsBlit</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">EffectMaterial</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span> <span class="c1">// Replace Graphics.Blit with CustomGraphicsBlit
</span><span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>In a normal <code class="highlighter-rouge">Graphics.Blit</code> implementation, the four calls to <code class="highlighter-rouge">GL.Vertex3</code> would all have z coordinates of 0.  However, with this modification, we assign the corresponding indices in <code class="highlighter-rouge">_FrustumCornersES</code> as the z coordinate.</p>

<h4 id="step-3-receiving-the-ray-directions-in-your-shader">Step 3: Receiving the Ray Directions in your Shader</h4>

<p>Finally, we are now ready to start writing the raymarching shader.  As a base, I will start with the default image effects shader (Assets &gt; Create &gt; Shader &gt; Image Effects Shader).  First, we need to edit the vertex shader to properly interpret <code class="highlighter-rouge">_FrustumCornersES</code>:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46</pre></td><td class="code"><pre><span class="c1">// Provided by our script
</span><span class="n">uniform</span> <span class="n">float4x4</span> <span class="n">_FrustumCornersES</span><span class="p">;</span>
<span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">_MainTex</span><span class="p">;</span>
<span class="n">uniform</span> <span class="n">float4</span> <span class="n">_MainTex_TexelSize</span><span class="p">;</span>
<span class="n">uniform</span> <span class="n">float4x4</span> <span class="n">_CameraInvViewMatrix</span><span class="p">;</span>

<span class="c1">// Input to vertex shader
</span><span class="k">struct</span> <span class="n">appdata</span>
<span class="p">{</span>
    <span class="c1">// Remember, the z value here contains the index of _FrustumCornersES to use
</span>    <span class="n">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="n">POSITION</span><span class="p">;</span>
    <span class="n">float2</span> <span class="n">uv</span> <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Output of vertex shader / input to fragment shader
</span><span class="k">struct</span> <span class="n">v2f</span>
<span class="p">{</span>
    <span class="n">float4</span> <span class="n">pos</span> <span class="o">:</span> <span class="n">SV_POSITION</span><span class="p">;</span>
    <span class="n">float2</span> <span class="n">uv</span> <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">ray</span> <span class="o">:</span> <span class="n">TEXCOORD1</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">v2f</span> <span class="nf">vert</span> <span class="p">(</span><span class="n">appdata</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>
    
    <span class="c1">// Index passed via custom blit function in RaymarchGeneric.cs
</span>    <span class="n">half</span> <span class="n">index</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
    <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">;</span>
    
    <span class="n">o</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">UNITY_MATRIX_MVP</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
    <span class="n">o</span><span class="p">.</span><span class="n">uv</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">xy</span><span class="p">;</span>
    
    <span class="cp">#if UNITY_UV_STARTS_AT_TOP
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">_MainTex_TexelSize</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">o</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">o</span><span class="p">.</span><span class="n">uv</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
    <span class="cp">#endif
</span>
    <span class="c1">// Get the eyespace view ray (normalized)
</span>    <span class="n">o</span><span class="p">.</span><span class="n">ray</span> <span class="o">=</span> <span class="n">_FrustumCornersES</span><span class="p">[(</span><span class="kt">int</span><span class="p">)</span><span class="n">index</span><span class="p">].</span><span class="n">xyz</span><span class="p">;</span>

    <span class="c1">// Transform the ray from eyespace to worldspace
</span>    <span class="c1">// Note: _CameraInvViewMatrix was provided by the script
</span>    <span class="n">o</span><span class="p">.</span><span class="n">ray</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">_CameraInvViewMatrix</span><span class="p">,</span> <span class="n">o</span><span class="p">.</span><span class="n">ray</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Much of the vertex shader so far should be familiar to Unity graphics programmers: as in most image effect shaders we pass the vertex positions and UV data to the fragment shader.  We also need to flip the UVs in the Y axis in some cases <a href="https://docs.unity3d.com/Manual/SL-PlatformDifferences.html">to prevent our output appearing upside-down</a>.  Of course, we also extract the corresponding ray from <code class="highlighter-rouge">_FrustumCornersES</code> that we are interested in, using the Z coordinate of the input vertex (these Z values were injected above in Step 2).  After the vertex shader finishes, the rays are interpolated by the GPU for each pixel.  We can now use these interpolated rays in the fragment shader!</p>

<p>As a test, try simply returning the ray direction in the fragment shader, like so:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre><span class="n">fixed4</span> <span class="n">frag</span> <span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span>
<span class="p">{</span>
    <span class="n">fixed4</span> <span class="n">col</span> <span class="o">=</span> <span class="n">fixed4</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">ray</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">col</span><span class="p">;</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>You should see the following visualization back in Unity:</p>

<div style="max-width:500px;display:block;margin:0 auto;">
    <div class="gfyitem" data-autoplay="true" data-responsive="true" data-id="SaltyIckyFiddlercrab"></div>
</div>
<p style="text-align: center">
    <i>Visualizing the world-space ray direction of each pixel.  Notice that, for example, when you look up the result is green.  This corresponds to the actual ray direction (0, 1, 0).</i>
</p>

<h3 id="building-the-distance-field">Building the Distance Field</h3>

<p>The next step is to construct the distance field that we are going to use.  As a reminder, the <strong>distance field</strong> defines what you are going to render (as opposed to 3D models/meshes in a traditional renderer).  Your distance field function takes in a point as input, and returns the distance from that point to the surface of the closest object in the scene.  If the point is inside an object, the distance field is negative.</p>

<p>Constructing a distance field is an incredibly involved and complex topic that is perhaps beyond the scope of this article.  Luckily, there are some excellent resources online about distance fields, such as <a href="http://iquilezles.org/www/articles/distfunctions/distfunctions.htm">this excellent resource from Inigo Quilez listing a number of common distance field primatives</a>.  For the purposes of this article, I will borrow from Inigo and draw a simple torus at the origin of the scene:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16</pre></td><td class="code"><pre><span class="c1">// Torus
// t.x: diameter
// t.y: thickness
// Adapted from: http://iquilezles.org/www/articles/distfunctions/distfunctions.htm
</span><span class="kt">float</span> <span class="nf">sdTorus</span><span class="p">(</span><span class="n">float3</span> <span class="n">p</span><span class="p">,</span> <span class="n">float2</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">float2</span> <span class="n">q</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span><span class="n">length</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">xz</span><span class="p">)</span> <span class="o">-</span> <span class="n">t</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">length</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">-</span> <span class="n">t</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// This is the distance field function.  The distance field represents the closest distance to the surface
// of any object we put in the scene.  If the given point (point p) is inside of an object, we return a
// negative answer.
</span><span class="kt">float</span> <span class="nf">map</span><span class="p">(</span><span class="n">float3</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">sdTorus</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">float2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">2</span><span class="p">));</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>In this case, <code class="highlighter-rouge">map</code> defines the distance field that describes a torus with diameter 1.0 and thickness 0.2, located at the origin of the scene.  This <code class="highlighter-rouge">map</code> function is perhaps the most creative and fun aspect of raymarching, so I recommend you have fun with it!  Try new primitives out, combinations of primitives, or even your own weird custom shapes!  Once again, you should <a href="http://iquilezles.org/www/articles/distfunctions/distfunctions.htm">check out this resource for more distance field equations</a>.</p>

<h3 id="writing-the-raymarch-function">Writing the Raymarch Function</h3>

<p>Now that we have built a distance field to sample, we can write the core raymarch loop.  This loop will be called from the fragment shader, and as explained at the top of this post, is responsible for “marching” a sample point along the current pixel’s ray.  The raymarch function returns a color: the color of whatever object the ray hits (or a completely transparent color if no object is found).  The raymarch function essentially boils down to a simple <code class="highlighter-rouge">for</code> loop, as shown below:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre></td><td class="code"><pre><span class="c1">// Raymarch along given ray
// ro: ray origin
// rd: ray direction
</span><span class="n">fixed4</span> <span class="nf">raymarch</span><span class="p">(</span><span class="n">float3</span> <span class="n">ro</span><span class="p">,</span> <span class="n">float3</span> <span class="n">rd</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fixed4</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">fixed4</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">maxstep</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// current distance traveled along ray
</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxstep</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">float3</span> <span class="n">p</span> <span class="o">=</span> <span class="n">ro</span> <span class="o">+</span> <span class="n">rd</span> <span class="o">*</span> <span class="n">t</span><span class="p">;</span> <span class="c1">// World space position of sample
</span>        <span class="kt">float</span> <span class="n">d</span> <span class="o">=</span> <span class="n">map</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>       <span class="c1">// Sample of distance field (see map())
</span>
        <span class="c1">// If the sample &lt;= 0, we have hit something (see map()).
</span>        <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">.</span><span class="mo">001</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Simply return a gray color if we have hit an object
</span>            <span class="c1">// We will deal with lighting later.
</span>            <span class="n">ret</span> <span class="o">=</span> <span class="n">fixed4</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// If the sample &gt; 0, we haven't hit anything yet so we should march forward
</span>        <span class="c1">// We step forward by distance d, because d is the minimum distance possible to intersect
</span>        <span class="c1">// an object (see map()).
</span>        <span class="n">t</span> <span class="o">+=</span> <span class="n">d</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>In each iteration of the raymarch loop, we sample a point along the ray.  If we hit something, then bail out of the loop and return a color (in other words, the color of the object).  If we don’t hit anything (the result of <code class="highlighter-rouge">map</code> is greater than zero) then we move forward by the distance given to us by the distance field.  If you’re confused, <a href="#introduction-to-raymarching">revisit the theory discussed at the beginning of the article</a>.</p>

<p>If you find yourself building extremely complex scenes with lots of small details, you may need to increase the <code class="highlighter-rouge">maxstep</code> constant on line 7 (at an increased performance cost).  You also might want to carefully tweak <code class="highlighter-rouge">maxstep</code> anyway to see how many samples you can get away with (64 samples in this case is overkill for a simple torus, but for the sake of example I’ll keep it).</p>

<p>Now all that’s left is to call <code class="highlighter-rouge">raymarch()</code> from the fragment shader.  This is simply done like so:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18</pre></td><td class="code"><pre><span class="c1">// Provided by our script
</span><span class="n">uniform</span> <span class="n">float3</span> <span class="n">_CameraWS</span><span class="p">;</span>

<span class="c1">// ...
</span>
<span class="n">fixed4</span> <span class="n">frag</span> <span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span>
<span class="p">{</span>
    <span class="c1">// ray direction
</span>    <span class="n">float3</span> <span class="n">rd</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">ray</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
    <span class="c1">// ray origin (camera position)
</span>    <span class="n">float3</span> <span class="n">ro</span> <span class="o">=</span> <span class="n">_CameraWS</span><span class="p">;</span>

    <span class="n">fixed3</span> <span class="n">col</span> <span class="o">=</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span><span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">);</span> <span class="c1">// Color of the scene before this shader was run
</span>    <span class="n">fixed4</span> <span class="n">add</span> <span class="o">=</span> <span class="n">raymarch</span><span class="p">(</span><span class="n">ro</span><span class="p">,</span> <span class="n">rd</span><span class="p">);</span>

    <span class="c1">// Returns final color using alpha blending
</span>    <span class="k">return</span> <span class="n">fixed4</span><span class="p">(</span><span class="n">col</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">-</span> <span class="n">add</span><span class="p">.</span><span class="n">w</span><span class="p">)</span> <span class="o">+</span> <span class="n">add</span><span class="p">.</span><span class="n">xyz</span> <span class="o">*</span> <span class="n">add</span><span class="p">.</span><span class="n">w</span><span class="p">,</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>All we are doing here is receiving our ray data from the vertex shader and passing it along to <code class="highlighter-rouge">raymarch()</code>.  We finally blend the result with <code class="highlighter-rouge">_MainTex</code> (the rendered scene before applying this shader) using standard <a href="https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending">alpha blending</a>.  Recall that <code class="highlighter-rouge">_CameraWS</code> represents the world-space position of the camera and was passed to the shader as a uniform <a href="#step-2-passing-the-rays-to-the-gpu">earlier in our C# script</a>.</p>

<p>Open up Unity again, and behold!  A torus!</p>

<div style="max-width:500px;display:block;margin:0 auto;">
    <div class="gfyitem" data-autoplay="true" data-responsive="true" data-id="WholeWeirdFirefly"></div>
</div>
<p style="text-align: center">
    <i>Look mom, no polygons!</i>
</p>

<h2 id="adding-lighting">Adding Lighting</h2>

<p>We have made some great progress thus far: by now we can render arbitrary shapes with infinite resolution using raymarching.  However, of course, it would be hard to actually use raymarched objects in a game without being able to light them (except, I guess, in some sort of abstract game).</p>

<p>To perform any sort of lighting calculation of an object, you must first calculate the normals of that object.  This is because light reflects off of objects as a function of their normals.  More concretely, any <a href="https://en.wikipedia.org/wiki/Bidirectional_reflectance_distribution_function">BDRF</a> requires the normal of the surface as input.  In a normal polygonal 3D mesh, it is easy to find the normals of the object, because finding the normals of a triangle is an <a href="https://en.wikipedia.org/wiki/Cross_product">easily solved problem</a>.  However, in our case finding the normals of an object inside of a distance field isn’t so obvious.</p>

<p>It turns out that, at any point on a surface defined in the distance field, the <em>gradient</em> of the distance field is the same as the normals of the object at that point.  The gradient of a scalar field (such as a signed distance field) is essentially the derivative of the field in the x, y, and z directions.  In other words, for each dimension <em>d</em> we fix the other two dimensions and approximate the derivative of the field along <em>d</em>.  Intuitively, the distance field value grows fastest when moving directly away from an object (that is, along it’s normal).  So, by calculating the gradient at some point we have also calculated the surface normal at that point.</p>

<p>Here is how we approximate this gradient in code:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15</pre></td><td class="code"><pre><span class="n">float3</span> <span class="nf">calcNormal</span><span class="p">(</span><span class="n">in</span> <span class="n">float3</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// epsilon - used to approximate dx when taking the derivative
</span>    <span class="k">const</span> <span class="n">float2</span> <span class="n">eps</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mo">001</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>

    <span class="c1">// The idea here is to find the "gradient" of the distance field at pos
</span>    <span class="c1">// Remember, the distance field is not boolean - even if you are inside an object
</span>    <span class="c1">// the number is negative, so this calculation still works.
</span>    <span class="c1">// Essentially you are approximating the derivative of the distance field at this point.
</span>    <span class="n">float3</span> <span class="n">nor</span> <span class="o">=</span> <span class="n">float3</span><span class="p">(</span>
        <span class="n">map</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">eps</span><span class="p">.</span><span class="n">xyy</span><span class="p">).</span><span class="n">x</span> <span class="o">-</span> <span class="n">map</span><span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="n">eps</span><span class="p">.</span><span class="n">xyy</span><span class="p">).</span><span class="n">x</span><span class="p">,</span>
        <span class="n">map</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">eps</span><span class="p">.</span><span class="n">yxy</span><span class="p">).</span><span class="n">x</span> <span class="o">-</span> <span class="n">map</span><span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="n">eps</span><span class="p">.</span><span class="n">yxy</span><span class="p">).</span><span class="n">x</span><span class="p">,</span>
        <span class="n">map</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">eps</span><span class="p">.</span><span class="n">yyx</span><span class="p">).</span><span class="n">x</span> <span class="o">-</span> <span class="n">map</span><span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="n">eps</span><span class="p">.</span><span class="n">yyx</span><span class="p">).</span><span class="n">x</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">normalize</span><span class="p">(</span><span class="n">nor</span><span class="p">);</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Be careful however, because this technique is quite expensive!  You have to calculate your distance field a total of 6  extra times for each pixel in order to find the gradient.</p>

<p>Now that we have the ability to find the normals of objects, we can begin to light things!  Of course, we need a light source first.  In order to pass a light source to our shader, we need to modify our scripts a bit:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></td><td class="code"><pre><span class="c1">// ...
</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">TutorialRaymarch</span> <span class="p">:</span> <span class="n">SceneViewFilter</span> <span class="p">{</span>

    <span class="c1">// ...
</span>
    <span class="k">public</span> <span class="n">Transform</span> <span class="n">SunLight</span><span class="p">;</span>

    <span class="c1">// ...
</span>
    <span class="k">void</span> <span class="nf">OnRenderImage</span><span class="p">(</span><span class="n">RenderTexture</span> <span class="n">source</span><span class="p">,</span> <span class="n">RenderTexture</span> <span class="n">destination</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// ...
</span>
        <span class="n">EffectMaterial</span><span class="p">.</span><span class="nf">SetVector</span><span class="p">(</span><span class="s">"_LightDir"</span><span class="p">,</span> <span class="n">SunLight</span> <span class="p">?</span> <span class="n">SunLight</span><span class="p">.</span><span class="n">forward</span> <span class="p">:</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">down</span><span class="p">);</span>

        <span class="c1">// ...
</span>
        <span class="nf">CustomGraphicsBlit</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">EffectMaterial</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// ...
</span><span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>These additions simply pass along a vector to our shader that describes the direction of the sun.  You can pass along more information (such as light intensity, color, etc.) if you would like, but we’ll keep it simple for now and assume that it is a simple white directional light with intensity 1.0.  This vector is passed to our scripts by the shader uniform <code class="highlighter-rouge">_LightDir</code>.  We can now use <code class="highlighter-rouge">_LightDir</code> along with <code class="highlighter-rouge">calcNormal()</code> to light our objects:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32</pre></td><td class="code"><pre><span class="c1">// ...
</span>
<span class="n">uniform</span> <span class="n">float3</span> <span class="n">_LightDir</span><span class="p">;</span>

<span class="c1">// ...
</span>
<span class="n">fixed4</span> <span class="nf">raymarch</span><span class="p">(</span><span class="n">float3</span> <span class="n">ro</span><span class="p">,</span> <span class="n">float3</span> <span class="n">rd</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fixed4</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">fixed4</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">maxstep</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// current distance traveled along ray
</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxstep</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">float3</span> <span class="n">p</span> <span class="o">=</span> <span class="n">ro</span> <span class="o">+</span> <span class="n">rd</span> <span class="o">*</span> <span class="n">t</span><span class="p">;</span> <span class="c1">// World space position of sample
</span>        <span class="kt">float</span> <span class="n">d</span> <span class="o">=</span> <span class="n">map</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>       <span class="c1">// Sample of distance field (see map())
</span>
        <span class="c1">// If the sample &lt;= 0, we have hit something (see map()).
</span>        <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">.</span><span class="mo">001</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Lambertian Lighting
</span>            <span class="n">float3</span> <span class="n">n</span> <span class="o">=</span> <span class="n">calcNormal</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">fixed4</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="o">-</span><span class="n">_LightDir</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">n</span><span class="p">).</span><span class="n">rrr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// If the sample &gt; 0, we haven't hit anything yet so we should march forward
</span>        <span class="c1">// We step forward by distance d, because d is the minimum distance possible to intersect
</span>        <span class="c1">// an object (see map()).
</span>        <span class="n">t</span> <span class="o">+=</span> <span class="n">d</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">//</span> <span class="p">...</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>We use the <a href="https://en.wikipedia.org/wiki/Lambert%27s_cosine_law">Lambertian Reflectance Model</a> above on lines 18-20, but you could use any <a href="https://en.wikipedia.org/wiki/Bidirectional_reflectance_distribution_function">BDRF</a> that you want (just like with normal 3D models!).  Back in the Unity editor, assign the script’s “Sun Light” attribute to a directional light in the scene, and you will find a very nicely lit torus indeed:</p>

<p style="text-align: center">
    <img src="/img/2016-10-01-raymarching/littorus.png" style="width: 100%; max-width: 300px;" /><br />
    <i>Our torus with lambertian lighting</i>
</p>

<h2 id="interacting-with-mesh-based-objects">Interacting With Mesh-Based Objects</h2>

<p>So now you have constructed a bunch of objects using distance fields and you are ready to integrate them into your Unity project.  However, you run into a major problem very quickly: Mesh-based objects and raymarched objects can’t interact with or touch each other!  In fact, the raymarched objects <em>always</em> float on top of everything else, because our raymarcher doesn’t take depth into account.  The video below illustrates this:</p>

<div style="max-width:500px;display:block;margin:0 auto;">
    <div class="gfyitem" data-autoplay="true" data-responsive="true" data-id="GrossThoroughEasternnewt"></div>
</div>
<p style="text-align: center">
    <i>My brain hurts...</i>
</p>

<p>To fix this problem, we need to find the distance along each ray at which the closest mesh-based object lies.  If our raymarch loop marches past this point, we bail out and render that object instead (because it is in front of any potential raymarched objects).</p>

<p>To find this distance, we need to take advantage of the depth buffer.  The depth buffer is accessible to all image effects shaders and stores the <em>eyespace</em> depth of the closest object in the scene for each pixel.  Refer to figure 5 below for more context.</p>

<p style="text-align: center">
    <img src="/img/2016-10-01-raymarching/figure5.png" style="width: 100%; max-width: 600px;" /><br />
    <i>Figure 5: Diagram of the measurements we are interested in when calculating depth.  The red line is the ray for some arbitrary pixel.</i>
</p>

<p>In Figure 5, the magnitude of <em>r</em> is the measurement that we are trying to find (depth beyond which we should bail out in the raymarch loop).  The magnitude of <em>d</em> is the eyespace depth that is given to us for that pixel by the depth buffer (note that <em>d</em> is shorter than <em>r</em>, because <em>d</em> does not account for perspective).</p>

<p>In order to find the magnitude of <em>r</em> we can simply leverage the rules of similar triangles.  Consider <em>r<sub>n</sub></em>, the vector with the same direction as <em>r</em> but with length 1.0 in the z direction.  We can write <em>r<sub>n</sub></em> as:</p>

<center><span class="math"><i>r<sub>n</sub> = r<sub>d</sub></i> &#247; (<i>r<sub>d</sub></i>)<i>.z</i></span></center>

<p>In the above equation, <em>r<sub>d</sub></em> is the vector with the same direction as <em>r</em> but with an arbitrary length (in other words, the ray vector that our shader is given). Clearly, from Figure 5 <em>r</em> and <em>r<sub>n</sub></em> create two similar triangles.  By multiplying <em>r<sub>n</sub></em> by <em>d</em> (which we know from the depth buffer) we can derive <em>r</em> and its magnitude as follows:</p>

<center>
    <span class="math">| <i>r</i> | / <i>d</i> = <i>r<sub>d</sub></i> / 1.0</span><br />
    <span class="math">| <i>r</i> | = <i>r<sub>d</sub></i> &#215; <i>d</i></span>
</center>

<h3 id="using-the-depth-buffer-in-our-shader">Using the depth buffer in our shader</h3>

<p>Now we need to make some modifications to our code to align with the above theory.  First, we need to make some changes to our vertex shader so that it returns <em>r<sub>n</sub></em> instead of <em>r<sub>d</sub></em>:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14</pre></td><td class="code"><pre><span class="n">v2f</span> <span class="nf">vert</span> <span class="p">(</span><span class="n">appdata</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ...
</span>
    <span class="c1">// Dividing by z "normalizes" it in the z axis
</span>    <span class="c1">// Therefore multiplying the ray by some number i gives the viewspace position
</span>    <span class="c1">// of the point on the ray with [viewspace z]=i
</span>    <span class="n">o</span><span class="p">.</span><span class="n">ray</span> <span class="o">/=</span> <span class="n">abs</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">ray</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>

    <span class="c1">// Transform the ray from eyespace to worldspace
</span>    <span class="n">o</span><span class="p">.</span><span class="n">ray</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">_CameraInvViewMatrix</span><span class="p">,</span> <span class="n">o</span><span class="p">.</span><span class="n">ray</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Note that we are dividing by <code class="highlighter-rouge">abs(o.ray.z)</code> instead of simply <code class="highlighter-rouge">o.ray.z</code>.  This is because in eyespace coordinates, <code class="highlighter-rouge">z &lt; 0</code> corresponds to the forward direction.  If we were to divide by a negative number, the ray direction would flip when dividing (and therefore the entire raymarched scene would appear flipped).</p>

<p>The final step is to integrate depth into our fragment shader and raymarch loop:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53</pre></td><td class="code"><pre><span class="c1">// Raymarch along given ray
// ro: ray origin
// rd: ray direction
// s: unity depth buffer
</span><span class="n">fixed4</span> <span class="nf">raymarch</span><span class="p">(</span><span class="n">float3</span> <span class="n">ro</span><span class="p">,</span> <span class="n">float3</span> <span class="n">rd</span><span class="p">,</span> <span class="kt">float</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fixed4</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">fixed4</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">maxstep</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// current distance traveled along ray
</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxstep</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// If we run past the depth buffer, stop and return nothing (transparent pixel)
</span>        <span class="c1">// this way raymarched objects and traditional meshes can coexist.
</span>        <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">fixed4</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// ...
</span>    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ...
</span><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">_CameraDepthTexture</span><span class="p">;</span>
<span class="c1">// ...
</span>
<span class="n">fixed4</span> <span class="n">frag</span> <span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span>
<span class="p">{</span>
    <span class="c1">// ray direction
</span>    <span class="n">float3</span> <span class="n">rd</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">ray</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
    <span class="c1">// ray origin (camera position)
</span>    <span class="n">float3</span> <span class="n">ro</span> <span class="o">=</span> <span class="n">_CameraWS</span><span class="p">;</span>

    <span class="n">float2</span> <span class="n">duv</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">;</span>
    <span class="cp">#if UNITY_UV_STARTS_AT_TOP
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">_MainTex_TexelSize</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">duv</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">duv</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
    <span class="cp">#endif
</span>
    <span class="c1">// Convert from depth buffer (eye space) to true distance from camera
</span>    <span class="c1">// This is done by multiplying the eyespace depth by the length of the "z-normalized"
</span>    <span class="c1">// ray (see vert()).  Think of similar triangles: the view-space z-distance between a point
</span>    <span class="c1">// and the camera is proportional to the absolute distance.
</span>    <span class="kt">float</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">LinearEyeDepth</span><span class="p">(</span><span class="n">tex2D</span><span class="p">(</span><span class="n">_CameraDepthTexture</span><span class="p">,</span> <span class="n">duv</span><span class="p">).</span><span class="n">r</span><span class="p">);</span>
    <span class="n">depth</span> <span class="o">*=</span> <span class="n">length</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">ray</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>

    <span class="n">fixed3</span> <span class="n">col</span> <span class="o">=</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span><span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">);</span>
    <span class="n">fixed4</span> <span class="n">add</span> <span class="o">=</span> <span class="n">raymarch</span><span class="p">(</span><span class="n">ro</span><span class="p">,</span> <span class="n">rd</span><span class="p">,</span> <span class="n">depth</span><span class="p">);</span>

    <span class="c1">// Returns final color using alpha blending
</span>    <span class="k">return</span> <span class="n">fixed4</span><span class="p">(</span><span class="n">col</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">-</span> <span class="n">add</span><span class="p">.</span><span class="n">w</span><span class="p">)</span> <span class="o">+</span> <span class="n">add</span><span class="p">.</span><span class="n">xyz</span> <span class="o">*</span> <span class="n">add</span><span class="p">.</span><span class="n">w</span><span class="p">,</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>On line 45, we access Unity’s depth texture using the standard Unity shader uniform <code class="highlighter-rouge">_CameraDepthTexture</code>, and convert it to eyespace depth using <code class="highlighter-rouge">LinearEyeDepth()</code>.  For more information about depth textures and Unity, <a href="https://docs.unity3d.com/Manual/SL-CameraDepthTexture.html">see this page from the Unity Manual</a>.  Next, on line 46, we multiply the depth by the length of <em>r<sub>n</sub></em>, which was passed to us by the vertex shader, satisfying the equations discussed above.</p>

<p>We then pass the depth as a new parameter to <code class="highlighter-rouge">raymarch()</code>.  In the raymarch loop, we bail out and return a completely transparent color if we march past the value given by the depth buffer (see lines 13-16).  Now, when we check back in Unity, our raymarched objects coexist with normal mesh-based objects as expected:</p>

<div style="max-width:500px;display:block;margin:0 auto;">
    <div class="gfyitem" data-autoplay="true" data-responsive="true" data-id="SimpleInfiniteBlackandtancoonhound"></div>
</div>

<h2 id="fun-with-distance-fields">Fun with Distance Fields</h2>

<p>Now that we have our raymarcher up and running, we can start to build scenes!  As I said earlier, this is a very deep rabbit hole and it is beyond the scope of this article to explore distance field construction entirely.  However, below are some simple techniques that I have tried out.  I recommend you check out some examples on <a href="https://www.shadertoy.com">Shadertoy</a> to spark your imagination.  In any case, below is a small sampler of some of the things that you can do:</p>

<h3 id="basic-transformations">Basic Transformations</h3>

<p>Just like with mesh-based 3D models, you can perform transformations on an object using a <a href="https://solarianprogrammer.com/2013/05/22/opengl-101-matrices-projection-view-model/">model matrix</a>.  In our case however, we need to compute the <em>inverse</em> of the model matrix since we aren’t actually transforming the model itself.  Rather, we are transforming the point that is used to sample our distance field.</p>

<p>To implement these transformations, we first build the model matrix in the image effect script and pass the inverse to the shader:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19</pre></td><td class="code"><pre><span class="na">[ImageEffectOpaque]</span>
<span class="k">void</span> <span class="nf">OnRenderImage</span><span class="p">(</span><span class="n">RenderTexture</span> <span class="n">source</span><span class="p">,</span> <span class="n">RenderTexture</span> <span class="n">destination</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ...
</span>    
    <span class="c1">// Construct a Model Matrix for the Torus
</span>    <span class="n">Matrix4x4</span> <span class="n">MatTorus</span> <span class="p">=</span> <span class="n">Matrix4x4</span><span class="p">.</span><span class="nf">TRS</span><span class="p">(</span>
        <span class="n">Vector3</span><span class="p">.</span><span class="n">right</span> <span class="p">*</span> <span class="n">Mathf</span><span class="p">.</span><span class="nf">Sin</span><span class="p">(</span><span class="n">Time</span><span class="p">.</span><span class="n">time</span><span class="p">)</span> <span class="p">*</span> <span class="m">5</span><span class="p">,</span> 
        <span class="n">Quaternion</span><span class="p">.</span><span class="n">identity</span><span class="p">,</span>
        <span class="n">Vector3</span><span class="p">.</span><span class="n">one</span><span class="p">);</span>
    <span class="n">MatTorus</span> <span class="p">*=</span> <span class="n">Matrix4x4</span><span class="p">.</span><span class="nf">TRS</span><span class="p">(</span>
        <span class="n">Vector3</span><span class="p">.</span><span class="n">zero</span><span class="p">,</span> 
        <span class="n">Quaternion</span><span class="p">.</span><span class="nf">Euler</span><span class="p">(</span><span class="k">new</span> <span class="nf">Vector3</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="p">(</span><span class="n">Time</span><span class="p">.</span><span class="n">time</span> <span class="p">*</span> <span class="m">200</span><span class="p">)</span> <span class="p">%</span> <span class="m">360</span><span class="p">)),</span> 
        <span class="n">Vector3</span><span class="p">.</span><span class="n">one</span><span class="p">);</span>
    <span class="c1">// Send the torus matrix to our shader
</span>    <span class="n">EffectMaterial</span><span class="p">.</span><span class="nf">SetMatrix</span><span class="p">(</span><span class="s">"_MatTorus_InvModel"</span><span class="p">,</span> <span class="n">MatTorus</span><span class="p">.</span><span class="n">inverse</span><span class="p">);</span>

    <span class="c1">// ...
</span><span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Note how you can use <code class="highlighter-rouge">Time.time</code> to animate objects.  You can also use any variables from your script (including, concievably, Unity’s animation system) to inform these transformations.  Next, we receive the Model Matrix in our shader and apply it to the torus:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre><span class="n">uniform</span> <span class="n">float4x4</span> <span class="n">_MatTorus_InvModel</span><span class="p">;</span>

<span class="kt">float</span> <span class="nf">map</span><span class="p">(</span><span class="n">float3</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float4</span> <span class="n">q</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">_MatTorus_InvModel</span><span class="p">,</span> <span class="n">float4</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span>
    
    <span class="k">return</span> <span class="n">sdTorus</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">float2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">2</span><span class="p">));</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>You’ll notice that the torus now moves nicely back and forth in Unity (enter play mode to see the animation):</p>

<div style="max-width:500px;display:block;margin:0 auto;">
    <div class="gfyitem" data-autoplay="true" data-responsive="true" data-id="TalkativeHopefulHowlermonkey"></div>
</div>

<h3 id="combining-objects">Combining Objects</h3>

<p>You can combine objects as well to create more complex forms.  To do this, you simply need to take advantage of some simple distance field combine operations: <code class="highlighter-rouge">opU()</code> (Union), <code class="highlighter-rouge">opI()</code> (Intersection), and <code class="highlighter-rouge">opS()</code> (Subtraction).  Below is an example distance field function that demonstrates the outcomes of these operations:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50</pre></td><td class="code"><pre><span class="c1">// Box
// b: size of box in x/y/z
// Adapted from: http://iquilezles.org/www/articles/distfunctions/distfunctions.htm
</span><span class="kt">float</span> <span class="nf">sdBox</span><span class="p">(</span><span class="n">float3</span> <span class="n">p</span><span class="p">,</span> <span class="n">float3</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">float3</span> <span class="n">d</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">min</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">max</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">d</span><span class="p">.</span><span class="n">z</span><span class="p">)),</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span>
        <span class="n">length</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// Union
// Adapted from: http://iquilezles.org/www/articles/distfunctions/distfunctions.htm
</span><span class="kt">float</span> <span class="nf">opU</span><span class="p">(</span> <span class="kt">float</span> <span class="n">d1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">d2</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">min</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span><span class="n">d2</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Subtraction
// Adapted from: http://iquilezles.org/www/articles/distfunctions/distfunctions.htm
</span><span class="kt">float</span> <span class="nf">opS</span><span class="p">(</span> <span class="kt">float</span> <span class="n">d1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">d2</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="o">-</span><span class="n">d1</span><span class="p">,</span><span class="n">d2</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Intersection
// Adapted from: http://iquilezles.org/www/articles/distfunctions/distfunctions.htm
</span><span class="kt">float</span> <span class="nf">opI</span><span class="p">(</span> <span class="kt">float</span> <span class="n">d1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">d2</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span><span class="n">d2</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="nf">map</span><span class="p">(</span><span class="n">float3</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">union_box</span> <span class="o">=</span> <span class="n">opU</span><span class="p">(</span>
        <span class="n">sdBox</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">float3</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">float3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span> 
        <span class="n">sdBox</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">float3</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">float3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="p">);</span>
    <span class="kt">float</span> <span class="n">subtr_box</span> <span class="o">=</span> <span class="n">opS</span><span class="p">(</span>
        <span class="n">sdBox</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">float3</span><span class="p">(</span><span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">float3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">.</span><span class="mo">01</span><span class="p">)),</span> 
        <span class="n">sdBox</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">float3</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">float3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="p">);</span>
    <span class="kt">float</span> <span class="n">insec_box</span> <span class="o">=</span> <span class="n">opI</span><span class="p">(</span>
        <span class="n">sdBox</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">float3</span><span class="p">(</span><span class="mi">3</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">float3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span> 
        <span class="n">sdBox</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">float3</span><span class="p">(</span><span class="mi">4</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">float3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="p">);</span>

    <span class="kt">float</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">opU</span><span class="p">(</span><span class="n">union_box</span><span class="p">,</span> <span class="n">subtr_box</span><span class="p">);</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">opU</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">insec_box</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>The result of this in Unity is shown below:</p>

<p style="text-align: center">
    <img src="/img/2016-10-01-raymarching/combine-operations.png" style="text-align: center; width: 100%; max-width: 500px;" /><br />
    <i>From Left to Right: Union, Subtraction, and Intersection Operators</i>
</p>

<h3 id="multiple-materials">Multiple Materials</h3>

<p>You can extend your distance field function to return material data as well.  Simply have your <code class="highlighter-rouge">map()</code> function return the relevant material information for each object - in the example below, we pull from a <em>color ramp</em> texture to pick which color each object is.  We also need to modify the <code class="highlighter-rouge">opU()</code> function introduced above to support multiple materials.</p>

<p style="text-align: center">
    <img src="/img/2016-10-01-raymarching/color_ramp.png" style="text-align: center; width: 100%; max-width: 500px;" /><br />
    <i>The Color Ramp I am using.</i>
</p>

<p>As always, we need to pass the color ramp to our shader through the image effect script:</p>

<figure class="highlight"><pre><code class="language-csharp" data-lang="csharp"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14</pre></td><td class="code"><pre><span class="na">[SerializeField]</span>
<span class="k">private</span> <span class="n">Texture2D</span> <span class="n">_ColorRamp</span><span class="p">;</span>

<span class="c1">// ...
</span>
<span class="na">[ImageEffectOpaque]</span>
<span class="k">void</span> <span class="nf">OnRenderImage</span><span class="p">(</span><span class="n">RenderTexture</span> <span class="n">source</span><span class="p">,</span> <span class="n">RenderTexture</span> <span class="n">destination</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ...
</span>
    <span class="n">EffectMaterial</span><span class="p">.</span><span class="nf">SetTexture</span><span class="p">(</span><span class="s">"_ColorRamp"</span><span class="p">,</span> <span class="n">_ColorRamp</span><span class="p">);</span>

    <span class="c1">// ...
</span><span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Next we can use the new <code class="highlighter-rouge">_ColorRamp</code> uniform in the shader.  As mentioned, we need to modify <code class="highlighter-rouge">map()</code> as well as the lighting calculation in <code class="highlighter-rouge">raymarch()</code> to leverage these different material properties.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51</pre></td><td class="code"><pre><span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">_ColorRamp</span><span class="p">;</span>

<span class="c1">// ...
</span>
<span class="c1">// Union (with material data)
</span><span class="n">float2</span> <span class="nf">opU</span><span class="p">(</span> <span class="n">float2</span> <span class="n">d1</span><span class="p">,</span> <span class="n">float2</span> <span class="n">d2</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">d1</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">d2</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">?</span> <span class="n">d1</span> <span class="o">:</span> <span class="n">d2</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Notice how map() now returns a float2
// \return.x: Distance field value
// \return.y: Color of closest object (0 - 1)
</span><span class="n">float2</span> <span class="nf">map</span><span class="p">(</span><span class="n">float3</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">float2</span> <span class="n">d_torus</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span><span class="n">sdTorus</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">float2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">2</span><span class="p">)),</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">);</span>
    <span class="n">float2</span> <span class="n">d_box</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span><span class="n">sdBox</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">float3</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">float3</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">75</span><span class="p">,</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)),</span> <span class="mi">0</span><span class="p">.</span><span class="mi">25</span><span class="p">);</span>
    <span class="n">float2</span> <span class="n">d_sphere</span> <span class="o">=</span> <span class="n">float2</span><span class="p">(</span><span class="n">sdSphere</span><span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="n">float3</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">.</span><span class="mi">75</span><span class="p">);</span>

    <span class="n">float2</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">opU</span><span class="p">(</span><span class="n">d_torus</span><span class="p">,</span> <span class="n">d_box</span><span class="p">);</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">opU</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">d_sphere</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">fixed4</span> <span class="nf">raymarch</span><span class="p">(</span><span class="n">float3</span> <span class="n">ro</span><span class="p">,</span> <span class="n">float3</span> <span class="n">rd</span><span class="p">,</span> <span class="kt">float</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fixed4</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">fixed4</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">maxstep</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// current distance traveled along ray
</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxstep</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ...
</span>
        <span class="n">float3</span> <span class="n">p</span> <span class="o">=</span> <span class="n">ro</span> <span class="o">+</span> <span class="n">rd</span> <span class="o">*</span> <span class="n">t</span><span class="p">;</span> <span class="c1">// World space position of sample
</span>        <span class="n">float2</span> <span class="n">d</span> <span class="o">=</span> <span class="n">map</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>      <span class="c1">// Sample of distance field (see map())
</span>                                <span class="c1">// d.x: distance field output
</span>                                <span class="c1">// d.y: material data
</span>
        <span class="c1">// If the sample &lt;= 0, we have hit something (see map()).
</span>        <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">.</span><span class="mo">001</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">float3</span> <span class="n">n</span> <span class="o">=</span> <span class="n">calcNormal</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
            <span class="kt">float</span> <span class="n">light</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="o">-</span><span class="n">_LightDir</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
            <span class="c1">// Use y value given by map() to choose a color from our Color Ramp
</span>            <span class="n">ret</span> <span class="o">=</span> <span class="n">fixed4</span><span class="p">(</span><span class="n">tex2D</span><span class="p">(</span><span class="n">_ColorRamp</span><span class="p">,</span> <span class="n">float2</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="mi">0</span><span class="p">)).</span><span class="n">xyz</span> <span class="o">*</span> <span class="n">light</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// ...
</span>    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Now, we have 3 objects with different colors:</p>

<p style="text-align: center">
    <img src="/img/2016-10-01-raymarching/materials.png" style="text-align: center; width: 100%; max-width: 500px;" /><br />
    <i>Raymarching with multiple materials</i>
</p>

<h3 id="performance-testing">Performance Testing</h3>

<p>It is often necessary to test the performance of your raymarch shader.  The best way to do this is to see how often <code class="highlighter-rouge">map()</code> is called per frame.  We can create a nice visualization of this by modifying <code class="highlighter-rouge">raymarch()</code> to output the number of samples per frame.  Simply map the number of samples in a given pixel to a Color Ramp, as in the previous section.</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></td><td class="code"><pre><span class="n">fixed4</span> <span class="nf">raymarch</span><span class="p">(</span><span class="n">float3</span> <span class="n">ro</span><span class="p">,</span> <span class="n">float3</span> <span class="n">rd</span><span class="p">,</span> <span class="kt">float</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">maxstep</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// current distance traveled along ray
</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxstep</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">float3</span> <span class="n">p</span> <span class="o">=</span> <span class="n">ro</span> <span class="o">+</span> <span class="n">rd</span> <span class="o">*</span> <span class="n">t</span><span class="p">;</span> <span class="c1">// World space position of sample
</span>        <span class="n">float2</span> <span class="n">d</span> <span class="o">=</span> <span class="n">map</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>      <span class="c1">// Sample of distance field (see map())
</span>
        <span class="c1">// If the sample &lt;= 0, we have hit something (see map()).
</span>        <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">.</span><span class="mo">001</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Simply return the number of steps taken, mapped to a color ramp.
</span>            <span class="kt">float</span> <span class="n">perf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">i</span> <span class="o">/</span> <span class="n">maxstep</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">fixed4</span><span class="p">(</span><span class="n">tex2D</span><span class="p">(</span><span class="n">_ColorRamp</span><span class="p">,</span> <span class="n">float2</span><span class="p">(</span><span class="n">perf</span><span class="p">,</span> <span class="mi">0</span><span class="p">)).</span><span class="n">xyz</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">t</span> <span class="o">+=</span> <span class="n">d</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// By this point the loop guard (i &lt; maxstep) is false.  Therefore
</span>    <span class="c1">// we have reached maxstep steps.
</span>    <span class="k">return</span> <span class="n">fixed4</span><span class="p">(</span><span class="n">tex2D</span><span class="p">(</span><span class="n">_ColorRamp</span><span class="p">,</span> <span class="n">float2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)).</span><span class="n">xyz</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>This is what the visualization looks like in Unity:</p>

<p style="text-align: center">
    <img src="/img/2016-10-01-raymarching/perftest.png" style="text-align: center; width: 100%; max-width: 500px;" /><br />
    <i>A performance visualization, with blue = lower step count and red = high step count.</i>
</p>

<p>The above visualization highlights a major problem in our algorithm.  The pixels that do not show any raymarched objects (most pixels fall under this category) display the maximum step size!  This makes sense: the rays cast from these pixels never hit anything, so they march onward forever.  To remedy this performance issue, we can add a maximum draw distance like so:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></td><td class="code"><pre><span class="n">fixed4</span> <span class="nf">raymarch</span><span class="p">(</span><span class="n">float3</span> <span class="n">ro</span><span class="p">,</span> <span class="n">float3</span> <span class="n">rd</span><span class="p">,</span> <span class="kt">float</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">maxstep</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">float</span> <span class="n">drawdist</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span> <span class="c1">// draw distance in unity units
</span>
    <span class="kt">float</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// current distance traveled along ray
</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxstep</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">float3</span> <span class="n">p</span> <span class="o">=</span> <span class="n">ro</span> <span class="o">+</span> <span class="n">rd</span> <span class="o">*</span> <span class="n">t</span><span class="p">;</span> <span class="c1">// World space position of sample
</span>        <span class="n">float2</span> <span class="n">d</span> <span class="o">=</span> <span class="n">map</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>      <span class="c1">// Sample of distance field (see map())
</span>
        <span class="c1">// If the sample &lt;= 0, we have hit something (see map()).
</span>        <span class="c1">// If t &gt; drawdist, we can safely bail because we have reached the max draw distance
</span>        <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">.</span><span class="mo">001</span> <span class="o">||</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="n">drawdist</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Simply return the number of steps taken, mapped to a color ramp.
</span>            <span class="kt">float</span> <span class="n">perf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">i</span> <span class="o">/</span> <span class="n">maxstep</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">fixed4</span><span class="p">(</span><span class="n">tex2D</span><span class="p">(</span><span class="n">_ColorRamp</span><span class="p">,</span> <span class="n">float2</span><span class="p">(</span><span class="n">perf</span><span class="p">,</span> <span class="mi">0</span><span class="p">)).</span><span class="n">xyz</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">t</span> <span class="o">+=</span> <span class="n">d</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// By this point the loop guard (i &lt; maxstep) is false.  Therefore
</span>    <span class="c1">// we have reached maxstep steps.
</span>    <span class="k">return</span> <span class="n">fixed4</span><span class="p">(</span><span class="n">tex2D</span><span class="p">(</span><span class="n">_ColorRamp</span><span class="p">,</span> <span class="n">float2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)).</span><span class="n">xyz</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Here’s our heatmap after the above optimization:</p>

<p style="text-align: center">
    <img src="/img/2016-10-01-raymarching/perftest2.png" style="text-align: center; width: 100%; max-width: 500px;" /><br />
    <i>Another performance visualization after the above optimization, with blue = lower step count and red = high step count.</i>
</p>

<p>Much better!  We can add this optimization to a normal raymarch loop by adding the draw distance check to the depth buffer culling check:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18</pre></td><td class="code"><pre><span class="n">fixed4</span> <span class="nf">raymarch</span><span class="p">(</span><span class="n">float3</span> <span class="n">ro</span><span class="p">,</span> <span class="n">float3</span> <span class="n">rd</span><span class="p">,</span> <span class="kt">float</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fixed4</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">fixed4</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">maxstep</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">float</span> <span class="n">drawdist</span> <span class="o">=</span> <span class="mi">40</span><span class="p">;</span> <span class="c1">// draw distance in unity units
</span>
    <span class="kt">float</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// current distance traveled along ray
</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxstep</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&gt;=</span> <span class="n">s</span> <span class="o">||</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="n">drawdist</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// check draw distance in additon to depth
</span>            <span class="n">ret</span> <span class="o">=</span> <span class="n">fixed4</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// ...
</span>    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h2 id="closing-remarks">Closing Remarks</h2>

<p>I hope that this article has given a fairly robust introduction to Distance Field Raymarching.  Once again you can find a complete reference implementation at <a href="https://github.com/Flafla2/Generic-Raymarch-Unity">this Github Repository</a>.  If you are interested in learning more, I would suggest looking at examples on <a href="https://www.shadertoy.com">Shadertoy</a> and at the resources referenced below.  Much of the techniques used in Distance Field Raymarching are not formally documented, so it is up to you to find them.  From a theoretical perspective, I haven’t touched on a whole bunch of interesting topics relating to raymarching including <a href="http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm">shadows</a>, ambient occlusion, <a href="http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm">complex domain operations</a>, complex procedural texturing techniques, etc.  I suggest you begin to do your own research on these tricks!</p>

<h2 id="references">References</h2>
<ul>
  <li><a href="http://www.iquilezles.org/www/index.htm">Inigo Quilez’s blog</a> is in my opinion the seminal resource on Raymarching Distance fields.  His articles discuss advanced raymarching techniques.
    <ul>
      <li><a href="http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm">This article in particular</a> is a very useful reference for Distance Field functions.</li>
    </ul>
  </li>
  <li><a href="http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html">This Article by 9bit Science</a> is a great writeup on the theory behind raymarching.</li>
  <li><a href="https://www.shadertoy.com">Shadertoy</a> is a web-based shader viewing site and hosts many striking examples of distance field raymarching (as well as other applications of raymarching such as volumetric lighting).  Every shader has full source code access, so it’s a great way to learn about different techniques.</li>
  <li><a href="http://gamedev.stackexchange.com/questions/67719/how-do-raymarch-shaders-work">This Gamedev Stackexchange discussion</a> gives some interesting background into how raymarching shaders work fundamentally, and offers some alternative usecases of raymarching such as volumetric lighting.</li>
</ul>

	<br />

	
	<h1>Comments</h1>
	<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'flafla2'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
	
</div>

		</div>
		<div id="footer"><a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/80x15.png" /></a><br />The original contents of this website are licensed by Adrian Biagioli (Flafla2) under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</div>
	</body>
</html>